var documenterSearchIndex = {"docs":
[{"location":"#LabeledArrays","page":"Home","title":"LabeledArrays","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Vectors for fast Int index retrieval, NamedMatrix with names as keys of arbitrary type and sparse index vectors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"TODO: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"generalized NamedArray implementation.\nexamples","category":"page"},{"location":"#Public-Documentation","page":"Home","title":"Public Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for LabeledArrays.jl's public interface.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ LabeledArrays ]\nOrder = [ :type, :function ]","category":"page"},{"location":"#LabeledArrays.LabeledMatrix","page":"Home","title":"LabeledArrays.LabeledMatrix","text":"A matrix, AbstractArray{T,2}, with a layer labeled rows and cols.\n\n\n\n\n\n","category":"type"},{"location":"#LabeledArrays.NBijection","page":"Home","title":"LabeledArrays.NBijection","text":"NBijection(x::Vector{T})\n\nKEY <-> Int, bijection map. Synonym to possibly better name EnumerationDict, or VectorDict.\n\nStore inverse indices in a Dict{T,I} as well as original Vector{T}.\n\ncopy: set to false to store x without copying. (make sure that Vector will be mutated only through NBijection API.\n\n\n\n\n\n","category":"type"},{"location":"#Base.get!-Tuple{Function,NBijection,Any}","page":"Home","title":"Base.get!","text":"Base.get!(f::Function,b::NBijection, key)\n\nCalls f(length(b),key) hook function if key !in b, push key to b.enumeration and store key=>index. Similar to get!(f,b::Dict, key).\n\nTODO: remove f(n,key)\n\njulia> x = NBijection(['a','b','c'])\njulia> get!(x,'b')\n2\n\njulia> get!((i,k)->println(\"neu\"), x, 'd')\nneu\n4\n\njulia> get!((i,k)->println(\"neu\"), x, 'd')\n4\n\n\n\n\n\n","category":"method"},{"location":"#Base.get!-Tuple{NBijection,Any}","page":"Home","title":"Base.get!","text":"Base.get!(b::NBijection, key)\n\nWhen key !in b.index, push nothing to b.enumeration and store key=>index.\n\njulia> x = NBijection(['a','b','c'])\njulia> get!(x,'b')\n2\n\njulia> get!(x,'d')\n4\n\njulia> get!(x,'d')\n4\n\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{NBijection,Integer}","page":"Home","title":"Base.getindex","text":"Base.getindex(b::NBijection,i::Integer)\n\nb.enumeration[i].\n\n\n\n\n\n","category":"method"},{"location":"#Base.keys-Tuple{NBijection}","page":"Home","title":"Base.keys","text":"keys(b::NBijection)\n\nterms are keys in sequence that share position index with some other  data structure, like a count matrix in Count.\n\n\n\n\n\n","category":"method"},{"location":"#Base.push!-Tuple{NBijection,Any}","page":"Home","title":"Base.push!","text":"Base.push!(b::NBijection, key)\n\nPush key to b.enumeration and store key=>index. Return last index.\n\n@asserts that key is not in index, fails otherwise. Consider get!.\n\n\n\n\n\n","category":"method"},{"location":"#LabeledArrays.bool-Tuple{LabeledArrays.LabeledMatrix}","page":"Home","title":"LabeledArrays.bool","text":"TODO: broadcasting\n\n\n\n\n\n","category":"method"},{"location":"#SparseArrays.nnz-Tuple{LinearAlgebra.Adjoint}","page":"Home","title":"SparseArrays.nnz","text":"nnz(x::LinearAlgebra.Adjoint)\n\nCall SparseArrays.nnz of transpose for performance.\n\n\n\n\n\n","category":"method"},{"location":"#SparseArrays.sparsevec-Tuple{NBijection,Any}","page":"Home","title":"SparseArrays.sparsevec","text":"sparse_vector(x::NBijection,sel)\n\nCreate a sparse vector representation of selected values in x::NBijection.\n\n\n\n\n\n","category":"method"}]
}
